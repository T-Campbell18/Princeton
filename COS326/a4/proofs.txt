NAME: Tyler Campbell
LOGIN: tylercc

Part 2, Assignment #4, COS 326
------------------------------


Part 2.1:
--------

Prove that for all a, b, c : complex,

cadd a (cadd b c) == cadd (cadd a b) c

Proof:

   cadd a (cadd b c)                                                      (LHS)
== cadd a (let (b1, b2) = b in let (c1, c2) = c in (b1+c1, b2+c2))        (eval)
== let (a1, a2) = a in let (bc1, bc2) = (let (b1, b2) = b in
 let (c1, c2) = c in (b1+c1, b2+c2)) in (a1+bc1, a2+bc2)                  (eval)
== (a1+b1+c1, a2+b2+c2)                                                   (eval)
== let (x, y) = (let (a1, a2) = a in let (b1, b2) = b             (reverse eval)
 in (a1+b1, a2+b2)) in let (c1, c2) = c in (x+c1, y+c2)
== cadd (cadd a b) c                                              (reverse eval)

QED!

Part 2.2:
---------

Prove that for all integer lists xs and ys,
max (maxs xs) (maxs ys) == (maxs (append xs ys)).

Clearly justify each step of your proof.

Proof:  By induction on the list xs.

case xs == []:

To show: max (maxs []) (maxs ys) == (maxs (append [] ys))

Proof:

max (maxs []) (maxs ys)
== max (min_int) maxs ys             (eval)
== (maxs ys)                         (min_int)
== maxs (append [] ys)               (reverse eval)


case xs == hd::tail:

IH: max (maxs tail) (maxs ys) == (maxs (append tail ys))

To show: max (maxs hd::tail) (maxs ys) == (maxs (append (hd::tail) ys))

Proof:

    max (maxs xs) (maxs ys)                                        (LHS)
 == max (maxs hd::tail) (maxs ys)                         (substitution)
 == max (max hd (maxs tail)) (maxs ys)                            (eval)
 == max hd (max (maxs tail) (maxs ys))                   (associativity)
 == max hd (maxs (append tail ys))                                  (IH)
 == maxs (hd::append tail ys)                             (reverse eval)
 == maxs (append (hd::tail) ys)                           (reverse eval)

QED!

Part 2.3:
---------

(a) Prove that for all integer lists l, bump1 l == bump2 l.

Proof: By induction on list l.

case l == []:

To show: bump1 [] == bump2 []

Proof:
    bump1 []                 (LHS)
 == map (fun x -> x + 1) [] (eval)
 == []                      (eval)
 == bump2 []        (reverse eval)

case l == hd::tail:

IH: bump1 tail == bump2 tail

To show: bump1 hd::tail == bump2 hd::tail

Proof:

    bump1 hd::tail                     (LHS)
 == map (fun x -> x+1) hd::tail       (eval)
 == (hd+1)::(map (fun x -> x+1) tail) (eval)
 == bump2 hd::tail            (reverse eval)

QED!


(b) Prove that for all integer lists l, bump1 l == bump3 l.

Proof: By induction on list l.

case l == []:

To show: bump1 [] = bump3 []

Proof:

    bump1 []                 (LHS)
 == map (fun x -> x + 1) [] (eval)
 == []                      (eval)
 == bump3 []        (reverse eval)

case l == hd::tail:

IH: bump1 tail = bump3 tail

To show: bump1 hd::tail == bump3 hd::tail

Proof:

    bump1 hd::tail                       (LHS)
 == map (fun x -> x+1) hd::tail         (eval)
 == (hd+1)::(map (fun x -> x+1) tail)   (eval)
 == (hd+1)::(bump1 tail)        (reverse eval)
 == (hd+1)::(bump3 tail)                  (IH)
 == bump3 hd::tail              (reverse eval)

QED!


(c) In one sentence, what's the big difference between parts (a) and (b)?

Part a has two applications of the map function (the same), but
Part b has two different applications: map and fold



Part 2.4:
---------

Either prove or disprove each of the following. You will do any proofs using
induction on lists and you will disprove any false statement by providing a
counter-example to the claim.  When you do a proof, be sure to use the
standard template for list proofs.

(a) For all l : ('a * 'b) list, zip(unzip l) == l.

Proof:  By induction on list l

case l = []:

To show: zip(unzip []) == []

Proof:

    zip(unzip [])  (LHS)
 == zip(([], [])) (eval)
 == []            (eval)

case l = hd::tail:

IH: zip(unzip(tail)) = tail

To show: zip(unzip (hd::tail)) = hd::tail

Proof:

    zip(unzip (hd::tail))                                             (LHS)
 == zip(match hd::tail with
          | [] -> ([],[])
          | (x,y)::tail ->
             let (xs,ys) = unzip tail in
             (x::xs, y::ys))                                         (eval)
 == let (xs', ys') = match xs with
    	| [] -> ([],[])
    	| (x,y)::tail -> let (xs,ys) = unzip tail in
      	  (x::xs, y::ys)
    in
    match (xs', ys') with
       | ([], _) -> []
       | (_, []) -> []
       | (x'::xrest, y'::yrest) -> (x', y')::zip(xrest, yrest)       (eval)

 == let (xs, ys) = unzip tail in
    let (xs', ys') = match xs with
      | [] -> ([], [])
      | (x, y)::tail -> (x::xs, y::ys)
    in
    match (xs', ys') with
      | ([], _) -> []
      | (_, []) -> []
      | (x'::xrest, y'::yrest) ->(x', y')::zip(xrest, yrest)  (re-write math)

 == (x', y')::zip(xrest, yrest)                                       (eval)
 == (x', y')::zip(xs, ys)                                     (substitution)
 == (x', y')::zip(unzip(tail))                                (reverse eval)
 == (x, y)::zip(unzip(tail))                                  (substitution)
 == hd::zip(unzip(tail))                                      (reverse eval)
 == hd::tail                                                            (IH)

QED!


(b) For all l1 : 'a list, l2 : 'b list, unzip(zip (l1,l2)) == (l1,l2).

Proof by counter-example.:
Let l1 = [3] and l2 = []
(l1,l2) = ([3],[0])

    unzip(zip(l1, l2))
 == unzip([])         [eval]
 == ([], [])          [eval]
 != ([3], [0])

Therefore, it is not the case that for all l1: 'a list, l2: 'b list
unzip(zip(l1,l2)) == (l1, l2)
